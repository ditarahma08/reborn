{"version":3,"file":"withSentry.js","sourceRoot":"","sources":["../../src/utils/withSentry.ts"],"names":[],"mappings":"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","sourcesContent":["import { captureException, flush, getCurrentHub, Handlers, startTransaction } from '@sentry/node';\nimport { extractTraceparentData, hasTracingEnabled } from '@sentry/tracing';\nimport { Transaction } from '@sentry/types';\nimport { addExceptionMechanism, isString, logger, stripUrlQueryAndFragment } from '@sentry/utils';\nimport * as domain from 'domain';\nimport { NextApiHandler, NextApiResponse } from 'next';\n\nconst { parseRequest } = Handlers;\n\n// purely for clarity\ntype WrappedNextApiHandler = NextApiHandler;\n\ntype AugmentedResponse = NextApiResponse & { __sentryTransaction?: Transaction };\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const withSentry = (handler: NextApiHandler): WrappedNextApiHandler => {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  return async (req, res) => {\n    // first order of business: monkeypatch `res.end()` so that it will wait for us to send events to sentry before it\n    // fires (if we don't do this, the lambda will close too early and events will be either delayed or lost)\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    res.end = wrapEndMethod(res.end);\n\n    // use a domain in order to prevent scope bleed between requests\n    const local = domain.create();\n    local.add(req);\n    local.add(res);\n\n    // `local.bind` causes everything to run inside a domain, just like `local.run` does, but it also lets the callback\n    // return a value. In our case, all any of the codepaths return is a promise of `void`, but nextjs still counts on\n    // getting that before it will finish the response.\n    const boundHandler = local.bind(async () => {\n      const currentScope = getCurrentHub().getScope();\n\n      if (currentScope) {\n        currentScope.addEventProcessor(event => parseRequest(event, req));\n\n        if (hasTracingEnabled()) {\n          // If there is a trace header set, extract the data from it (parentSpanId, traceId, and sampling decision)\n          let traceparentData;\n          if (req.headers && isString(req.headers['sentry-trace'])) {\n            traceparentData = extractTraceparentData(req.headers['sentry-trace'] as string);\n            logger.log(`[Tracing] Continuing trace ${traceparentData?.traceId}.`);\n          }\n\n          const url = `${req.url}`;\n          // pull off query string, if any\n          let reqPath = stripUrlQueryAndFragment(url);\n          // Replace with placeholder\n          if (req.query) {\n            // TODO get this from next if possible, to avoid accidentally replacing non-dynamic parts of the path if\n            // they match dynamic parts\n            for (const [key, value] of Object.entries(req.query)) {\n              reqPath = reqPath.replace(`${value}`, `[${key}]`);\n            }\n          }\n          const reqMethod = `${(req.method || 'GET').toUpperCase()} `;\n\n          const transaction = startTransaction(\n            {\n              name: `${reqMethod}${reqPath}`,\n              op: 'http.server',\n              ...traceparentData,\n            },\n            // extra context passed to the `tracesSampler`\n            { request: req },\n          );\n          currentScope.setSpan(transaction);\n\n          // save a link to the transaction on the response, so that even if there's an error (landing us outside of\n          // the domain), we can still finish it (albeit possibly missing some scope data)\n          (res as AugmentedResponse).__sentryTransaction = transaction;\n        }\n      }\n\n      try {\n        return await handler(req, res); // Call original handler\n      } catch (e) {\n        if (currentScope) {\n          currentScope.addEventProcessor(event => {\n            addExceptionMechanism(event, {\n              handled: false,\n            });\n            return event;\n          });\n          captureException(e);\n        }\n        throw e;\n      }\n    });\n\n    return await boundHandler();\n  };\n};\n\ntype ResponseEndMethod = AugmentedResponse['end'];\ntype WrappedResponseEndMethod = AugmentedResponse['end'];\n\nfunction wrapEndMethod(origEnd: ResponseEndMethod): WrappedResponseEndMethod {\n  return async function newEnd(this: AugmentedResponse, ...args: unknown[]) {\n    const transaction = this.__sentryTransaction;\n\n    if (transaction) {\n      transaction.setHttpStatus(this.statusCode);\n\n      // Push `transaction.finish` to the next event loop so open spans have a better chance of finishing before the\n      // transaction closes, and make sure to wait until that's done before flushing events\n      const transactionFinished: Promise<void> = new Promise(resolve => {\n        setImmediate(() => {\n          transaction.finish();\n          resolve();\n        });\n      });\n      await transactionFinished;\n    }\n\n    // flush the event queue to ensure that events get sent to Sentry before the response is finished and the lambda\n    // ends\n    try {\n      logger.log('Flushing events...');\n      await flush(2000);\n      logger.log('Done flushing events');\n    } catch (e) {\n      logger.log(`Error while flushing events:\\n${e}`);\n    }\n\n    return origEnd.call(this, ...args);\n  };\n}\n"]}