var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var node_1 = require("@sentry/node");
var tracing_1 = require("@sentry/tracing");
var utils_1 = require("@sentry/utils");
var domain = require("domain");
var parseRequest = node_1.Handlers.parseRequest;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
exports.withSentry = function (handler) {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    return function (req, res) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var local, boundHandler;
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    // first order of business: monkeypatch `res.end()` so that it will wait for us to send events to sentry before it
                    // fires (if we don't do this, the lambda will close too early and events will be either delayed or lost)
                    // eslint-disable-next-line @typescript-eslint/unbound-method
                    res.end = wrapEndMethod(res.end);
                    local = domain.create();
                    local.add(req);
                    local.add(res);
                    boundHandler = local.bind(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var currentScope, traceparentData, url, reqPath, _a, _b, _c, key, value, reqMethod, transaction, e_1;
                        var e_2, _d;
                        var _e;
                        return tslib_1.__generator(this, function (_f) {
                            switch (_f.label) {
                                case 0:
                                    currentScope = node_1.getCurrentHub().getScope();
                                    if (currentScope) {
                                        currentScope.addEventProcessor(function (event) { return parseRequest(event, req); });
                                        if (tracing_1.hasTracingEnabled()) {
                                            traceparentData = void 0;
                                            if (req.headers && utils_1.isString(req.headers['sentry-trace'])) {
                                                traceparentData = tracing_1.extractTraceparentData(req.headers['sentry-trace']);
                                                utils_1.logger.log("[Tracing] Continuing trace " + ((_e = traceparentData) === null || _e === void 0 ? void 0 : _e.traceId) + ".");
                                            }
                                            url = "" + req.url;
                                            reqPath = utils_1.stripUrlQueryAndFragment(url);
                                            // Replace with placeholder
                                            if (req.query) {
                                                try {
                                                    // TODO get this from next if possible, to avoid accidentally replacing non-dynamic parts of the path if
                                                    // they match dynamic parts
                                                    for (_a = tslib_1.__values(Object.entries(req.query)), _b = _a.next(); !_b.done; _b = _a.next()) {
                                                        _c = tslib_1.__read(_b.value, 2), key = _c[0], value = _c[1];
                                                        reqPath = reqPath.replace("" + value, "[" + key + "]");
                                                    }
                                                }
                                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                                finally {
                                                    try {
                                                        if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                                                    }
                                                    finally { if (e_2) throw e_2.error; }
                                                }
                                            }
                                            reqMethod = (req.method || 'GET').toUpperCase() + " ";
                                            transaction = node_1.startTransaction(tslib_1.__assign({ name: "" + reqMethod + reqPath, op: 'http.server' }, traceparentData), 
                                            // extra context passed to the `tracesSampler`
                                            { request: req });
                                            currentScope.setSpan(transaction);
                                            // save a link to the transaction on the response, so that even if there's an error (landing us outside of
                                            // the domain), we can still finish it (albeit possibly missing some scope data)
                                            res.__sentryTransaction = transaction;
                                        }
                                    }
                                    _f.label = 1;
                                case 1:
                                    _f.trys.push([1, 3, , 4]);
                                    return [4 /*yield*/, handler(req, res)];
                                case 2: return [2 /*return*/, _f.sent()]; // Call original handler
                                case 3:
                                    e_1 = _f.sent();
                                    if (currentScope) {
                                        currentScope.addEventProcessor(function (event) {
                                            utils_1.addExceptionMechanism(event, {
                                                handled: false,
                                            });
                                            return event;
                                        });
                                        node_1.captureException(e_1);
                                    }
                                    throw e_1;
                                case 4: return [2 /*return*/];
                            }
                        });
                    }); });
                    return [4 /*yield*/, boundHandler()];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    }); };
};
function wrapEndMethod(origEnd) {
    return function newEnd() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var transaction, transactionFinished, e_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        transaction = this.__sentryTransaction;
                        if (!transaction) return [3 /*break*/, 2];
                        transaction.setHttpStatus(this.statusCode);
                        transactionFinished = new Promise(function (resolve) {
                            setImmediate(function () {
                                transaction.finish();
                                resolve();
                            });
                        });
                        return [4 /*yield*/, transactionFinished];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        utils_1.logger.log('Flushing events...');
                        return [4 /*yield*/, node_1.flush(2000)];
                    case 3:
                        _a.sent();
                        utils_1.logger.log('Done flushing events');
                        return [3 /*break*/, 5];
                    case 4:
                        e_3 = _a.sent();
                        utils_1.logger.log("Error while flushing events:\n" + e_3);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/, origEnd.call.apply(origEnd, tslib_1.__spread([this], args))];
                }
            });
        });
    };
}
//# sourceMappingURL=withSentry.js.map