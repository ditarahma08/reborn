Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var integrations_1 = require("@sentry/integrations");
var node_1 = require("@sentry/node");
var utils_1 = require("@sentry/utils");
var instrumentServer_1 = require("./utils/instrumentServer");
var metadataBuilder_1 = require("./utils/metadataBuilder");
var userIntegrations_1 = require("./utils/userIntegrations");
tslib_1.__exportStar(require("@sentry/node"), exports);
// Here we want to make sure to only include what doesn't have browser specifics
// because or SSR of next.js we can only use this.
var react_1 = require("@sentry/react");
exports.ErrorBoundary = react_1.ErrorBoundary;
exports.withErrorBoundary = react_1.withErrorBoundary;
/** Inits the Sentry NextJS SDK on node. */
function init(options) {
    if (options.debug) {
        utils_1.logger.enable();
    }
    utils_1.logger.log('Initializing SDK...');
    if (sdkAlreadyInitialized()) {
        utils_1.logger.log('SDK already initialized');
        return;
    }
    var metadataBuilder = new metadataBuilder_1.MetadataBuilder(options, ['nextjs', 'node']);
    metadataBuilder.addSdkMetadata();
    options.environment = options.environment || process.env.NODE_ENV;
    // TODO capture project root and store in an env var for RewriteFrames?
    addServerIntegrations(options);
    // Right now we only capture frontend sessions for Next.js
    options.autoSessionTracking = false;
    node_1.init(options);
    node_1.configureScope(function (scope) {
        scope.setTag('runtime', 'node');
    });
    utils_1.logger.log('SDK successfully initialized');
}
exports.init = init;
function sdkAlreadyInitialized() {
    var hub = node_1.getCurrentHub();
    return !!hub.getClient();
}
var SOURCEMAP_FILENAME_REGEX = /^.*\/\.next\//;
var defaultRewriteFramesIntegration = new integrations_1.RewriteFrames({
    iteratee: function (frame) {
        var _a;
        frame.filename = (_a = frame.filename) === null || _a === void 0 ? void 0 : _a.replace(SOURCEMAP_FILENAME_REGEX, 'app:///_next/');
        return frame;
    },
});
var defaultHttpTracingIntegration = new node_1.Integrations.Http({ tracing: true });
function addServerIntegrations(options) {
    if (options.integrations) {
        options.integrations = userIntegrations_1.addIntegration(defaultRewriteFramesIntegration, options.integrations);
    }
    else {
        options.integrations = [defaultRewriteFramesIntegration];
    }
    if (options.tracesSampleRate !== undefined || options.tracesSampler !== undefined) {
        options.integrations = userIntegrations_1.addIntegration(defaultHttpTracingIntegration, options.integrations, {
            Http: { keyPath: '_tracing', value: true },
        });
    }
}
var config_1 = require("./config");
exports.withSentryConfig = config_1.withSentryConfig;
var withSentry_1 = require("./utils/withSentry");
exports.withSentry = withSentry_1.withSentry;
// wrap various server methods to enable error monitoring and tracing
instrumentServer_1.instrumentServer();
//# sourceMappingURL=index.server.js.map